title: web缓存
author: LightXJ
date: 2020-04-20 17:42:18
tags:
---

## 一、什么是web缓存（或HTTP缓存）？
Web缓存（或HTTP缓存）是用于临时存储（缓存）Web文档（如HTML页面和图像），以减少服务器延迟的一种信息技术。Web缓存系统会保存下通过这套系统的文档的副本；如果满足某些条件，则可以由缓存满足后续请求。 Web缓存系统既可以指设备，也可以指计算机程序。

## 二、web缓存的作用
• 缓存减少了冗余的数据传输，节省了你的网络费用。
• 缓存缓解了网络瓶颈的问题。不需要更多的带宽就能够更快地加载页面。
• 缓存降低了对原始服务器的要求。服务器可以更快地响应，避免过载的出现。 
• 缓存降低了距离时延，因为从较远的地方加载页面会更慢一些。 

## 三、web缓存的种类

#### 1.数据库缓存
   我们可能听说过memcached，它就是一种数据库层面的缓存方案。数据库缓存是指，当web应用的关系比较复杂，数据库中的表很多的时候，如果频繁进行数据库查询，很容易导致数据库不堪重荷。为了提供查询的性能，将查询后的数据放到内存中进行缓存，下次查询时，直接从内存缓存直接返回，提供响应效率。

#### 2.CDN缓存
  CDN缓存一般是由网站管理员自己部署，为了让他们的网站更容易扩展并获得更好的性能。通常情况下，浏览器先向CDN网关发起Web请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态将请求转发到合适的源服务器上。从浏览器角度来看，整个CDN就是一个源服务器，从这个层面来说，浏览器和服务器之间的缓存机制，在这种架构下同样适用。

#### 3.代理服务器缓存
   代理服务器是浏览器和源服务器之间的中间服务器，浏览器先向这个中间服务器发起Web请求，经过处理后（比如权限验证，缓存匹配等），再将请求转发到源服务器。代理服务器缓存的运作原理跟浏览器的运作原理差不多，只是规模更大。

#### 4.浏览器缓存
   每个浏览器都实现了 HTTP 缓存，我们通过浏览器使用HTTP协议与服务器交互的时候，浏览器就会根据一套与服务器约定的规则进行缓存工作。

#### 5.应用层缓存
  应用层缓存指的是从代码层面上，通过代码逻辑和缓存策略，实现对数据，页面，图片等资源的缓存，可以根据实际情况选择将数据存在文件系统或者内存中，减少数据库查询或者读写瓶颈，提高响应效率。

另一种分类方式是：

#### 1、私有缓存
私有缓存不需要很大的动力或存储空间，这样就可以将其做得很小，很便宜。Web 浏 览器中有内建的私有缓存——大多数浏览器都会将常用文档缓存在你个人电脑的磁盘 和内存中，并且允许用户去配置缓存的大小和各种设置。chrome浏览器就有私有缓存，可以通过chrome://cache/查看
#### 2、公有缓存
公有缓存是特殊的共享代理服务器，被称为缓存代理服务器(caching proxy server)，或者更常见地被称为代理缓存(proxy cache)。代理缓存会从本地缓存中提供文档，或者代表用户与服务器进行联系。公有缓存会接受来自多个用户的访问，所以通过它可以更好地减少冗余流量。


### 四、缓存的处理步骤



### 五、服务器再验证
* 如果再验证显示内容发生了变化，缓存会获取一份新的文档副本，并将其存储在旧文档的位置上，然后将文档发送给客户端。 
* 如果再验证显示内容没有发生变化，缓存只需要获取新的首部，包括一个新的过期日期，并对缓存中的首部进行更新就行了

#### 验证方式：条件验证



那么什么时候用实体标签ETag或者最后修改日期Last-Modified-Since进行验证？
如果服务器回送了一个实体标签，HTTP/1.1 客户端就必须使用实体标签验证器。如果服务器只回送了一个 Last-Modified 值，客户端就可以使用 If-Modified-Since 验证。
如果实体标签和最后修改日期都提供了，客户端就应该使用这两种再验证方案，这样 HTTP/1.0 和 HTTP/1.1 缓存就都可以正确响应了。这种情况下，两者都满足时，才能返回 304 Not Modified 响应。

### 六、服务器控制缓存
服务器可以通过 HTTP 定义的几种方式来指定在文档过期之前可以将其缓存多长时间。按照**优先级递减**的顺序，服务器可以:
* 附加一个 Cache-Control: no-store 首部到响应中去; 
* 附加一个 Cache-Control: no-cache 首部到响应中去; 
* 附加一个 Cache-Control: must-revalidate 首部到响应中去; 
* 附加一个 Cache-Control: max-age=< seconds > 首部到响应中去;
* 附加一个 Expires 日期首部到响应中去; 
* 不附加过期信息，让缓存确定自己的过期日期。 

下面详细解释一下他们的区别：
#### no-store与no-cache响应首部
Pragma: no-cache 
Cache-Control: no-store 
Cache-Control: no-cache
标识为 no-store 的响应会禁止缓存对响应进行复制。缓存通常会像非缓存代理服务器一样，向客户端转发一条 no-store 响应，然后删除对象。
标识为 no-cache 的响应实际上是可以存储在本地缓存区中的。只是在与**原始服务器**进行新鲜度再验证之前，缓存不能将其提供给客户端使用。这个首部使用 do-not-serve-from-cache-without-revalidation 这个名字会更恰当一些。
HTTP/1.1 中提供Pragma: no-cache 首部是为了兼容于HTTP/1.0+。除了与只理解 Pragma: no-cache 的 HTTP/1.0 应用程序进行交互时，HTTP 1.1 应用程序都应该使用 Cache-Control: no-cache。

#### max-age响应首部
Cache-Control: max-age首部表示的是从服务器将文档传来之时起，可以认为此文档处于新鲜状态的**秒数**。
还有一个s-maxage** 首部(注意 maxage 的中间没有连字符)，其行为与 max-age 类似，但仅适用于共享(公有)缓存。
使用方式：Cache-Control: max-age=3600 Cache-Control: s-maxage=3600

服务器可以请求缓存不要缓存文档，或者将最大使用期设置为零，从而在每次访问的时候都进行刷新:
Cache-Control: max-age=0 Cache-Control: s-maxage=0

#### Expires响应首部
**不推荐使用Expires首部**，它指定的是实际的过期日期而不是秒数。HTTP设计者后来认为，由于很多服务器的时钟都不同步，或者不正确，所以最好还是用剩余秒数，而不是绝对时间来表示过期时间。

#### must-revalidate响应首部
Cache-Control: must-revalidate 响应首部告诉缓存，在事先没有跟**原始服务器**进行再验证的情况下，不能提供这个对象的陈旧副本。缓存仍然可以随意提供新鲜的副本。通俗的将就是告诉浏览器、缓存服务器，本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去源服务器进行有效性校验。如果在缓存进行 must-revalidate 新鲜度检查时，原始服务器不可用，缓存就必须返回一条 504 Gateway Timeout 错误。
如果响应头的 Cache-Control 只有 max-age 指令（并且没有 stale-while-revalidate 指令），客户端会默认使用 must-revalidate 策略 (Chromium 源码), 在重新验证之后会 重置过期时间 。
实践举例：
1、第一次请求img1.jpeg资源，响应头里返回 Cache-Control:max-age=60
2、然后60s内再次请求：直接从缓存中读取，没有去请求源服务器
3、60s后，源文件没变化，再去请求，返回304 Not Modified，并且更新了缓存时间。
4、接下来60s内，直接从缓存读取。

#### 试探性过期
如果响应中没有 Cache-Control: max-age 首部，也没有Expires首部，缓存可以计算出一个试探性最大使用期。可以使用任意算法，但如果得到的最大使用期大 于 24 小时，就应该向响应首部添加一个 Heuristic Expiration Warning(试探性过期 警告，警告 13)首部。
它们可能比你想象的要常见得多。很多原始服 务器仍然不会产生 Expires 和 max-age 首部。选择缓存过期的默认时间时要特别小心!
实践举例：
服务器没有返回Cache-Control也没有Expires首部，但是在此请求资源时使用了缓存。

### 七、客户端的新鲜度限制
Web 浏览器都有 Refresh(刷新)或 Reload(重载)按钮，可以强制对浏览器或 代理缓存中可能过期的内容进行刷新。Refresh 按钮会发布一个附加了 Cache- Control 请求首部的 GET 请求，这个请求会强制进行再验证，或者无条件地从服 务器获取文档。Refresh 的确切行为取决于特定的浏览器、文档以及拦截缓存的配置。
客户端可以用 Cache-Control 请求首部来强化或放松对过期时间的限制。有些应 用程序对文档的新鲜度要求很高(比如人工刷新按钮)，对这些应用程序来说，客 户端可以用 Cache-Control 首部使过期时间更严格。另一方面，作为提高性能、 可靠性或开支的一种折衷方式，客户端可能会放松新鲜度要求。表 7-4 对 Cache- Control 请求指令进行了总结。



### 八、缓存优先级问题



### 九、如果304的请求，返回新的cache-control:max-age等，会更新本地的缓存吗？

八、缓存与广告
很多内容提供商的收益都是通过广告实现的——具体来说，每 向用户显示一次广告内容，内容提供商就会得到相应的收益。(可能还不到一两便 士，但如果一天显示数百万条广告的话，这些钱就会叠加起来!)这就是缓存的问 题——它们会向原始服务器隐藏实际的访问次数。如果缓存工作得很好，原始服务 器可能根本收不到任何 HTTP 访问，因为这些访问都被因特网缓存吸收了。
所以现在，广告商会使用各种类型的“缓存清除”技术来确保缓存不会窃取他们的命中 流量。他们会在内容上加上 no-cache 首部。他们会通过 CGI 网关提供广告。还会 在每次访问时重写广告 URL。
理想情况下，内容提供商会让缓存吸收其流量，而缓存会告诉内容提供商它们拦截 了多少次命中。现在，缓存有好几种方式可以做到这一点。
一种解决方案就是配置缓存，每次访问时都与原始服务器进行再验证。这样，每次 访问时都会将命中推向原始服务器，但通常不会传送任何主体数据。当然，这样会 降低事务处理的速度。

九、问题
1、响应中新鲜度信息是怎么加的？难道不是原生服务器增加的吗？如果原始服务器没有返回这些信息，缓存是根据什么来增加的，缓存时间是多长？


2、请求首部的cache-control是如何加上的？
比如我请求一个资源，请求头中就有cache-control：….，这种信息，如果是浏览器的refresh或者reload可以理解，是浏览器为每个请求加上的，那要是不是refresh或者relaod呢？比如例如js插入一幅图片，请求图片地址时可以有cache-control吗？还有服务器给客户端返回的cache-control和这个请求首部的cache-control有没有联系呢？

回答：首先，浏览器的reload或者refresh并不是给页面中的每个请求都加，而是给当前刷新时的请求加max-age=0或者cache-control:no-cache。所以js插入一幅图片，去请求时浏览器不会自动加max-age=0或者cache-control:no-cache的。
服务器给客户端返回的cache-control和这个请求首部的cache-control没有联系，是分别独立的。但是如果一个请求返回了Etag,last-modified首部的话，下次请求原服务器会带上这两个字段。

3、disk cache 和 memory cache的区别?
200 OK (from memory cache)
200 OK (from disk cache)
请求静态资源时这两种情况都存在
200 from memory cache

不访问服务器，直接读缓存，从内存中读取缓存。此时的数据时缓存到内存中的，当kill进程后，也就是浏览器关闭以后，数据将不存在。但是这种方式只能缓存派生资源。
200 from disk cache

不访问服务器，直接读缓存，从磁盘中读取缓存，当kill进程时，数据还是存在。这种方式也只能缓存派生资源 。


十、在前端性能优化中应用HTTP缓存的三部曲


十一、持久化缓存



十二、参考
1、HTTP权威指南
2、在前端性能优化中应用HTTP缓存的三部曲https://zhuanlan.zhihu.com/p/25404480


未完..内容待填充